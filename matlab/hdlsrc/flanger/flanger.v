// -------------------------------------------------------------
// 
// File Name: hdlsrc/flanger/flanger.v
// Created: 2024-11-11 02:24:59
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.4
// Target subsystem base rate: 0.4
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        0.4
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Out1                          ce_out        0.4
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: flanger
// Source Path: flanger
// Hierarchy Level: 0
// Model version: 1.8
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module flanger
          (clk,
           reset_n,
           clk_enable,
           In1,
           ce_out,
           Out1);


  input   clk;
  input   reset_n;
  input   clk_enable;
  input   signed [15:0] In1;  // int16
  output  ce_out;
  output  signed [15:0] Out1;  // int16


  wire enb;
  wire [31:0] TmpGroundAtDelayInport2_out1;  // uint32
  wire [31:0] ctrlSat;  // uint32
  wire signed [31:0] Gain7_out1;  // sfix32_En14
  wire signed [31:0] Sum4_out1;  // sfix32_En14
  reg signed [31:0] Delay2_out1;  // sfix32_En14
  wire signed [63:0] Gain6_mul_temp;  // sfix64_En45
  wire signed [31:0] Gain6_out1;  // sfix32_En14
  reg signed [31:0] Delay_reg [0:1023];  // sfix32 [1024]
  reg signed [31:0] Delay_reg_next [0:1023];  // sfix32_En14 [1024]
  reg signed [31:0] delayTapWire [0:1024];  // sfix32_En14 [1025]
  wire signed [31:0] multiportswitch_idx;  // int32
  wire [32:0] multiportswitch_add_temp;  // ufix33
  wire [32:0] multiportswitch_1;  // ufix33
  wire signed [31:0] Delay_out1;  // sfix32_En14
  reg signed [31:0] Delay1_out1;  // sfix32_En14
  wire signed [63:0] Gain4_mul_temp;  // sfix64_En46
  wire signed [31:0] Gain4_out1;  // sfix32_En14
  wire signed [31:0] Sum3_out1;  // sfix32_En14
  wire signed [63:0] Gain3_out1;  // sfix64_En46
  wire signed [63:0] Sum2_add_cast;  // sfix64_En46
  wire signed [63:0] Sum2_out1;  // sfix64_En46
  wire signed [127:0] Gain2_out1;  // sfix128_En108
  wire signed [63:0] Gain5_out1;  // sfix64_En45
  wire signed [127:0] Sum1_add_cast;  // sfix128_En108
  wire signed [127:0] Sum1_out1;  // sfix128_En108
  wire signed [15:0] Data_Type_Conversion1_out1;  // int16
  reg signed [31:0] Delay_t_0_0;  // int32
  reg signed [31:0] Delay_t_1;  // int32
  reg signed [31:0] Delay_t_0_1;  // int32
  reg signed [31:0] Delay_t_1_0;  // int32


  assign TmpGroundAtDelayInport2_out1 = 32'b00000000000000000000000000000000;



  assign ctrlSat = (TmpGroundAtDelayInport2_out1 > 32'b00000000000000000000010000000000 ? 32'b00000000000000000000010000000000 :
              TmpGroundAtDelayInport2_out1);



  assign Gain7_out1 = {{2{In1[15]}}, {In1, 14'b00000000000000}};



  assign enb = clk_enable;

  always @(posedge clk or negedge reset_n)
    begin : Delay2_process
      if (reset_n == 1'b0) begin
        Delay2_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Sum4_out1;
        end
      end
    end



  assign Gain6_mul_temp = 32'sb10100101011111011011111101001000 * Delay2_out1;
  assign Gain6_out1 = Gain6_mul_temp[62:31];



  assign Sum4_out1 = Gain7_out1 + Gain6_out1;



  always @(posedge clk or negedge reset_n)
    begin : Delay_process
      if (reset_n == 1'b0) begin
        for(Delay_t_1_0 = 32'sd0; Delay_t_1_0 <= 32'sd1023; Delay_t_1_0 = Delay_t_1_0 + 32'sd1) begin
          Delay_reg[Delay_t_1_0] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay_t_0_1 = 32'sd0; Delay_t_0_1 <= 32'sd1023; Delay_t_0_1 = Delay_t_0_1 + 32'sd1) begin
            Delay_reg[Delay_t_0_1] <= Delay_reg_next[Delay_t_0_1];
          end
        end
      end
    end

  always @* begin
    delayTapWire[0] = Sum4_out1;

    for(Delay_t_0_0 = 32'sd0; Delay_t_0_0 <= 32'sd1023; Delay_t_0_0 = Delay_t_0_0 + 32'sd1) begin
      delayTapWire[Delay_t_0_0 + 32'sd1] = Delay_reg[Delay_t_0_0];
    end

    Delay_reg_next[0] = Sum4_out1;

    for(Delay_t_1 = 32'sd0; Delay_t_1 <= 32'sd1022; Delay_t_1 = Delay_t_1 + 32'sd1) begin
      Delay_reg_next[Delay_t_1 + 32'sd1] = Delay_reg[Delay_t_1];
    end

  end



  assign multiportswitch_1 = {1'b0, ctrlSat};
  assign multiportswitch_add_temp = multiportswitch_1 + 33'h000000001;
  assign multiportswitch_idx = (multiportswitch_add_temp[32:31] != 2'b00 ? 32'sb01111111111111111111111111111111 :
              $signed(multiportswitch_add_temp[31:0]));
  assign Delay_out1 = ((multiportswitch_idx >= 32'sd1) && (multiportswitch_idx <= 32'sd1025) ? delayTapWire[multiportswitch_idx - 32'sd1] :
              delayTapWire[1024]);



  assign Gain4_mul_temp = 32'sb10011001100110011001100110011010 * Delay1_out1;
  assign Gain4_out1 = Gain4_mul_temp[63:32];



  assign Sum3_out1 = Delay_out1 + Gain4_out1;



  always @(posedge clk or negedge reset_n)
    begin : Delay1_process
      if (reset_n == 1'b0) begin
        Delay1_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Sum3_out1;
        end
      end
    end



  assign Gain3_out1 = 32'sb01100110011001100110011001100110 * Sum3_out1;



  assign Sum2_add_cast = {Delay1_out1, 32'b00000000000000000000000000000000};
  assign Sum2_out1 = Sum2_add_cast + Gain3_out1;



  assign Gain2_out1 = {{2{Sum2_out1[63]}}, {Sum2_out1, 62'b00000000000000000000000000000000000000000000000000000000000000}};



  assign Gain5_out1 = 32'sb01011010100000100100000010111000 * Sum4_out1;



  assign Sum1_add_cast = {Gain5_out1[63], {Gain5_out1, 63'b000000000000000000000000000000000000000000000000000000000000000}};
  assign Sum1_out1 = Gain2_out1 + Sum1_add_cast;



  assign Data_Type_Conversion1_out1 = Sum1_out1[123:108];



  assign Out1 = Data_Type_Conversion1_out1;

  assign ce_out = clk_enable;

endmodule  // flanger

