// -------------------------------------------------------------
// 
// File Name: hdlsrc/echo/echo.v
// Created: 2024-11-11 02:20:56
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.4
// Target subsystem base rate: 0.4
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        0.4
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Out1                          ce_out        0.4
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: echo
// Source Path: echo
// Hierarchy Level: 0
// Model version: 1.3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module echo
          (clk,
           reset_n,
           clk_enable,
           In1,
           In2,
           ce_out,
           Out1);


  input   clk;
  input   reset_n;
  input   clk_enable;
  input   signed [15:0] In1;  // int16
  input   [31:0] In2;  // uint32
  output  ce_out;
  output  signed [15:0] Out1;  // int16


  wire enb;
  wire [31:0] ctrlSat;  // uint32
  wire signed [31:0] Gain5_out1;  // sfix32_En14
  wire signed [31:0] Sum_out1;  // sfix32_En14
  reg signed [31:0] Delay_out1;  // sfix32_En14
  wire signed [63:0] Gain_mul_temp;  // sfix64_En47
  wire signed [31:0] Gain_out1;  // sfix32_En14
  reg signed [31:0] Delay1_reg [0:1023];  // sfix32 [1024]
  reg signed [31:0] Delay1_reg_next [0:1023];  // sfix32_En14 [1024]
  reg signed [31:0] delayTapWire [0:1024];  // sfix32_En14 [1025]
  wire signed [31:0] multiportswitch_idx;  // int32
  wire [32:0] multiportswitch_add_temp;  // ufix33
  wire [32:0] multiportswitch_1;  // ufix33
  wire signed [31:0] Delay1_out1;  // sfix32_En14
  wire signed [63:0] Gain1_out1;  // sfix64_En45
  wire signed [63:0] Gain2_out1;  // sfix64_En44
  wire signed [63:0] Sum1_add_cast;  // sfix64_En44
  wire signed [63:0] Sum1_out1;  // sfix64_En44
  wire signed [15:0] Data_Type_Conversion1_out1;  // int16
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_1;  // int32
  reg signed [31:0] Delay1_t_0_1;  // int32
  reg signed [31:0] Delay1_t_1_0;  // int32


  assign ctrlSat = (In2 > 32'b00000000000000000000010000000000 ? 32'b00000000000000000000010000000000 :
              In2);



  assign Gain5_out1 = {{2{In1[15]}}, {In1, 14'b00000000000000}};



  assign enb = clk_enable;

  always @(posedge clk or negedge reset_n)
    begin : Delay_process
      if (reset_n == 1'b0) begin
        Delay_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1 <= Sum_out1;
        end
      end
    end



  assign Gain_mul_temp = 32'sb01100110011001100110011001100110 * Delay_out1;
  assign Gain_out1 = {Gain_mul_temp[63], Gain_mul_temp[63:33]};



  assign Sum_out1 = Gain5_out1 + Gain_out1;



  always @(posedge clk or negedge reset_n)
    begin : Delay1_process
      if (reset_n == 1'b0) begin
        for(Delay1_t_1_0 = 32'sd0; Delay1_t_1_0 <= 32'sd1023; Delay1_t_1_0 = Delay1_t_1_0 + 32'sd1) begin
          Delay1_reg[Delay1_t_1_0] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay1_t_0_1 = 32'sd0; Delay1_t_0_1 <= 32'sd1023; Delay1_t_0_1 = Delay1_t_0_1 + 32'sd1) begin
            Delay1_reg[Delay1_t_0_1] <= Delay1_reg_next[Delay1_t_0_1];
          end
        end
      end
    end

  always @* begin
    delayTapWire[0] = Sum_out1;

    for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd1023; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
      delayTapWire[Delay1_t_0_0 + 32'sd1] = Delay1_reg[Delay1_t_0_0];
    end

    Delay1_reg_next[0] = Sum_out1;

    for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd1022; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
      Delay1_reg_next[Delay1_t_1 + 32'sd1] = Delay1_reg[Delay1_t_1];
    end

  end



  assign multiportswitch_1 = {1'b0, ctrlSat};
  assign multiportswitch_add_temp = multiportswitch_1 + 33'h000000001;
  assign multiportswitch_idx = (multiportswitch_add_temp[32:31] != 2'b00 ? 32'sb01111111111111111111111111111111 :
              $signed(multiportswitch_add_temp[31:0]));
  assign Delay1_out1 = ((multiportswitch_idx >= 32'sd1) && (multiportswitch_idx <= 32'sd1025) ? delayTapWire[multiportswitch_idx - 32'sd1] :
              delayTapWire[1024]);



  assign Gain1_out1 = 32'sb01100110011001100110011001100110 * Delay1_out1;



  assign Gain2_out1 = {{2{Sum_out1[31]}}, {Sum_out1, 30'b000000000000000000000000000000}};



  assign Sum1_add_cast = {Gain1_out1[63], Gain1_out1[63:1]};
  assign Sum1_out1 = Sum1_add_cast + Gain2_out1;



  assign Data_Type_Conversion1_out1 = Sum1_out1[59:44];



  assign Out1 = Data_Type_Conversion1_out1;

  assign ce_out = clk_enable;

endmodule  // echo

