// -------------------------------------------------------------
// 
// File Name: hdlsrc/chorus/chorus.v
// Created: 2024-11-02 21:34:31
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.4
// Target subsystem base rate: 0.4
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        0.4
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Out1                          ce_out        0.4
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: chorus
// Source Path: chorus
// Hierarchy Level: 0
// Model version: 1.11
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module chorus
  (clk,
   rst_n,
   clk_enable,
   In1,
   In2,
   ce_out,
   Out1);


    input          clk;
    input          rst_n;
    input          clk_enable;
    input signed [31:0] In1;  // int32
    input [15:0]          In2;  // uint16
    output                ce_out;
    output signed [31:0] Out1;  // int32


    wire                  enb;
    wire signed [16:0]    Sine;  // sfix17_En15
    wire signed [33:0]    Gain4_mul_temp;  // sfix34_En28
    wire signed [15:0]    Gain4_out1;  // int16
    wire signed [15:0]    Constant_out1;  // int16
    wire signed [15:0]    Sum2_out1;  // int16
    wire [31:0]           Data_Type_Conversion_out1;  // uint32
    wire [31:0]           ctrlSat;  // uint32
    reg signed [31:0]     Delay1_reg [0:1023];  // sfix32 [1024]
    reg signed [31:0]     Delay1_reg_next [0:1023];  // sfix32 [1024]
    reg signed [31:0]     delayTapWire [0:1024];  // int32 [1025]
    wire signed [31:0]    multiportswitch_idx;  // int32
    wire [32:0]           multiportswitch_add_temp;  // ufix33
    wire [32:0]           multiportswitch_1;  // ufix33
    wire signed [31:0]    Delay1_out1;  // int32
    wire signed [63:0]    Gain1_out1;  // sfix64_En31
    wire signed [63:0]    Gain2_out1;  // sfix64_En30
    wire signed [31:0]    Sum1_add_cast;  // sfix32
    wire signed [32:0]    Sum1_add_cast_1;  // sfix33
    wire signed [31:0]    Sum1_add_cast_2;  // sfix32
    wire signed [32:0]    Sum1_add_cast_3;  // sfix33
    wire signed [32:0]    Sum1_add_temp;  // sfix33
    wire signed [31:0]    Sum1_out1;  // int32
    reg signed [31:0]     Delay1_t_0_0;  // int32
    reg signed [31:0]     Delay1_t_1;  // int32
    reg signed [31:0]     Delay1_t_0_1;  // int32
    reg signed [31:0]     Delay1_t_1_0;  // int32


    Cosine_HDL_Optimized u_Cosine_HDL_Optimized (.u(In2),  // uint16
                                              .x(Sine)  // sfix17_En15
                                              );

    assign Gain4_mul_temp = 17'sb01010000000000000 * Sine;
    assign Gain4_out1 = ({{10{Gain4_mul_temp[33]}}, Gain4_mul_temp[33:28]}) + $signed({1'b0, Gain4_mul_temp[27] & (( ~ Gain4_mul_temp[33]) | (|Gain4_mul_temp[26:0]))});



    assign Constant_out1 = 16'sb0000000000000110;



    assign Sum2_out1 = Gain4_out1 + Constant_out1;



    assign Data_Type_Conversion_out1 = {{16{Sum2_out1[15]}}, Sum2_out1};



    assign ctrlSat = (Data_Type_Conversion_out1 > 32'b00000000000000000000010000000000 ? 32'b00000000000000000000010000000000 :
                   Data_Type_Conversion_out1);



    assign enb = clk_enable;

    always @(posedge clk or negedge rst_n)
      begin : Delay1_process
          if (rst_n == 1'b0) begin
              for(Delay1_t_1_0 = 32'sd0; Delay1_t_1_0 <= 32'sd1023; Delay1_t_1_0 = Delay1_t_1_0 + 32'sd1) begin
                  Delay1_reg[Delay1_t_1_0] <= 32'sb00000000000000000000000000000000;
              end
          end
          else begin
              if (enb) begin
                  for(Delay1_t_0_1 = 32'sd0; Delay1_t_0_1 <= 32'sd1023; Delay1_t_0_1 = Delay1_t_0_1 + 32'sd1) begin
                      Delay1_reg[Delay1_t_0_1] <= Delay1_reg_next[Delay1_t_0_1];
                  end
              end
          end
      end

    always @* begin
        delayTapWire[0] = In1;

        for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd1023; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
            delayTapWire[Delay1_t_0_0 + 32'sd1] = Delay1_reg[Delay1_t_0_0];
        end

        Delay1_reg_next[0] = In1;

        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd1022; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
            Delay1_reg_next[Delay1_t_1 + 32'sd1] = Delay1_reg[Delay1_t_1];
        end

    end



    assign multiportswitch_1 = {1'b0, ctrlSat};
    assign multiportswitch_add_temp = multiportswitch_1 + 33'h000000001;
    assign multiportswitch_idx = (multiportswitch_add_temp[32:31] != 2'b00 ? 32'sb01111111111111111111111111111111 :
                                  $signed(multiportswitch_add_temp[31:0]));
    assign Delay1_out1 = ((multiportswitch_idx >= 32'sd1) && (multiportswitch_idx <= 32'sd1025) ? delayTapWire[multiportswitch_idx - 32'sd1] :
                          delayTapWire[1024]);



    assign Gain1_out1 = 32'sb01011010011111101111100111011011 * Delay1_out1;



    assign Gain2_out1 = {{2{In1[31]}}, {In1, 30'b000000000000000000000000000000}};



    assign Sum1_add_cast = (((Gain1_out1[63] == 1'b0) && (Gain1_out1[62] != 1'b0)) || ((Gain1_out1[63] == 1'b0) && (Gain1_out1[62:31] == 32'sb01111111111111111111111111111111)) ? 32'sb01111111111111111111111111111111 :
                         ((Gain1_out1[63] == 1'b1) && (Gain1_out1[62] != 1'b1) ? 32'sb10000000000000000000000000000000 :
                          Gain1_out1[62:31] + $signed({1'b0, Gain1_out1[30] & (( ~ Gain1_out1[63]) | (|Gain1_out1[29:0]))})));
    assign Sum1_add_cast_1 = {Sum1_add_cast[31], Sum1_add_cast};
    assign Sum1_add_cast_2 = (((Gain2_out1[63] == 1'b0) && (Gain2_out1[62:61] != 2'b00)) || ((Gain2_out1[63] == 1'b0) && (Gain2_out1[61:30] == 32'sb01111111111111111111111111111111)) ? 32'sb01111111111111111111111111111111 :
                              ((Gain2_out1[63] == 1'b1) && (Gain2_out1[62:61] != 2'b11) ? 32'sb10000000000000000000000000000000 :
                               Gain2_out1[61:30] + $signed({1'b0, Gain2_out1[29] & (( ~ Gain2_out1[63]) | (|Gain2_out1[28:0]))})));
    assign Sum1_add_cast_3 = {Sum1_add_cast_2[31], Sum1_add_cast_2};
    assign Sum1_add_temp = Sum1_add_cast_1 + Sum1_add_cast_3;
    assign Sum1_out1 = ((Sum1_add_temp[32] == 1'b0) && (Sum1_add_temp[31] != 1'b0) ? 32'sb01111111111111111111111111111111 :
                        ((Sum1_add_temp[32] == 1'b1) && (Sum1_add_temp[31] != 1'b1) ? 32'sb10000000000000000000000000000000 :
                         $signed(Sum1_add_temp[31:0])));



    assign Out1 = Sum1_out1;

    assign ce_out = clk_enable;

endmodule  // chorus

